import asyncio
import datetime
import random
import re
import time

import psycopg2
from telethon import TelegramClient
from telethon import errors
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.tl.functions.channels import LeaveChannelRequest
from telethon.tl.functions.messages import GetBotCallbackAnswerRequest

print(f"–ì–æ—Ç–æ–≤ –≤–∫–∞–ª—ã–≤–∞—Ç—å")
#playsound('readytowork.mp3')
#time.sleep(1)

f = open('password.txt', 'r')
password = f.read()

async def workThread(x):
    await asyncio.sleep(random.uniform(0.1, 0.5))
    connect = psycopg2.connect(dbname='parsedaccounts', user='postgres',
                        password=password, host='localhost')
    cur = connect.cursor()
    cur.execute(f"SELECT API_ID FROM RegistredBots WHERE ID = {x}")
    Api_id = cur.fetchone()[0]
    await asyncio.sleep(random.uniform(0.1, 0.5))
    cur.execute(f"SELECT API_HASH FROM RegistredBots WHERE ID = {x}")
    Api_hash = cur.fetchone()[0]
    await asyncio.sleep(random.uniform(0.1, 0.5))
    cur.execute(f"SELECT Session FROM RegistredBots WHERE ID = {x}")
    await asyncio.sleep(random.uniform(0.1, 0.5))
    cur.execute(f"SELECT Session FROM RegistredBots WHERE ID = {x}")
    Session = cur.fetchone()[0]
    print("–¢–ï–°–¢ 3 –∑–∞–¥–∞–Ω–∏–µ")
    connect.close()
    client = TelegramClient(Session, Api_id, Api_hash)

    print(f"–ü–æ—Ä–∞ –æ–±–ª–æ–ø–æ—à–∏—Ç—å —ç—Ç–∏—Ö –ø–∏–¥–æ—Ä–æ–≤")
    await client.start()
    new_file_content = ""
    print(f"–£—Å–ø–µ—à–Ω—ã–π –≤—Ö–æ–¥ –≤ –∞–∫–∫–∞—É–Ω—Ç - bot id - {x}")
    sorry_count = 0
    count = 0
    max_count = 1
    error_count = 0
    not_free_found = False
    while True:


        if count == max_count:
            print("–•–≤–∞—Ç–∏—Ç —ç—Ç–∏—Ö –µ–±–∞–Ω—ã—Ö –≥—Ä—É–ø–ø")
            break
        if sorry_count == 5:
            print("–•–≤–∞—Ç–∏—Ç –∏–∑–≤–∏–Ω—è—Ç—Å—è –µ–±—É—á–∏–π –±–æ—Ç")

        if error_count == 5:
            print("–ï–±–∞–Ω—ã–µ –æ—à–∏–±–∫–∏")
            break
        try:
            dialogs = await client.get_dialogs()
            for dialog in dialogs:
                if dialog.title == 'LTC Click Bot':
                    thisdialog = dialog
                    print(thisdialog.title)
            await client.send_message('LTC Click Bot', 'üì£ Join chats')
            time.sleep(2)
            msgs = await client.get_messages(thisdialog, limit=1)
            for mes in msgs:
                if re.search(r"\bSorry\b", mes.message):
                    print("–ü–∏–¥–æ—Ä—ã –∏–∑–≤–∏–Ω—è—é—Ç—Å—è")
                    sorry_count += 1
                entity = mes.reply_markup.rows[0].buttons[0].url
                agree = mes.reply_markup.rows[0].buttons[1].data
                message_id = mes.id
                time.sleep(3)
            print(entity)
        except errors.FloodWaitError as e:
            print(f'–ù–∞—Å –æ–ø—Ä–∞–∫–∏–Ω—É–ª–∏ –µ–±–∞–ª–æ–º –≤ –≥—Ä—è–∑—å —Å–∏–¥–∏–º {e.seconds} —Å–µ–∫—É–Ω–¥ –Ω–∞ –±–æ—Ç–µ {x}')
            time.sleep(e.seconds)



        try:
            await asyncio.sleep(random.uniform(5, 10))
            await client(JoinChannelRequest(entity))
            await asyncio.sleep(random.uniform(0.1, 0.5))
            print(entity)
            channel_name = entity
        except errors.ChannelsTooMuchError:
            print("–ù–µ—Ç—É —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞. –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –≤—ã—Ö–æ–¥–∞ —Å –æ–¥–Ω–æ–≥–æ –∏–∑ –∫–∞–Ω–∞–ª–æ–≤")
            error_count += 1
            connect = psycopg2.connect(dbname='parsedaccounts', user='postgres',
                                       password=password, host='localhost')
            cur = connect.cursor()
            cur.execute(f"SELECT id,channel, leave_time FROM channel_entity WHERE bot_id = {x}")
            all_channels = cur.fetchall()
            for channel in all_channels:
                if channel[2] < datetime.datetime.now():
                    print(f"–î–∞ {channel[0]}/ {channel[1]} /{channel[2]}  < {datetime.datetime.now()}")
                    try:
                        await asyncio.sleep(random.uniform(5, 10))
                        await client(LeaveChannelRequest(channel[1]))
                        await asyncio.sleep(random.uniform(0.1, 0.5))
                    except errors.FloodWaitError as e:
                        print(f'–ù–∞—Å –æ–ø—Ä–∞–∫–∏–Ω—É–ª–∏ –µ–±–∞–ª–æ–º –≤ –≥—Ä—è–∑—å —Å–∏–¥–∏–º {e.seconds} —Å–µ–∫—É–Ω–¥ –Ω–∞ –±–æ—Ç–µ {x}')
                        time.sleep(e.seconds)
                    finally:
                        not_free_found = False
                        cur.execute(f"DELETE FROM channel_entity WHERE id = {channel[0]}")
                        connect.commit()
                        break

                else:
                    not_free_found = True
                    print(f"–ù–µ—Ç {channel[0]}/ {channel[1]} /{channel[2]}  > {datetime.datetime.now()}")
            connect.close()
        except errors.FloodWaitError as e:
            print(f'–ù–∞—Å –æ–ø—Ä–∞–∫–∏–Ω—É–ª–∏ –µ–±–∞–ª–æ–º –≤ –≥—Ä—è–∑—å —Å–∏–¥–∏–º {e.seconds} —Å–µ–∫—É–Ω–¥ –Ω–∞ –±–æ—Ç–µ {x}')
            time.sleep(e.seconds)
        if not_free_found is True:
            print("–°–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞ –¥–ª—è –∫–∞–Ω–∞–ª–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ...")
            break
        time.sleep(5)
        await client(GetBotCallbackAnswerRequest(
            thisdialog,
            message_id,
            data=agree
        ))
        time.sleep(3)
        msgs = await client.get_messages(thisdialog, limit=2)
        for mes2 in msgs:
            if re.search("Success!", mes2.message):
                waitin = str(mes2.message).replace("Success! üëç\nYou must stay in the channel for at least ", "")
                waitin = str(waitin).replace("Success! üëç\nYou must stay in the group for at least ", "")
                if re.search(" hour to earn your reward.", waitin):
                    waitin = str(waitin).replace(" hour to earn your reward.", "")
                else:
                    waitin = str(waitin).replace(" hours to earn your reward.", "")

                print(f"–ñ–¥–∞—Ç—å {waitin} —á–∞—Å–∞. –î–∞ –∏ –ø–æ—Ö—É–π –≥–æ –Ω–µ–∫—Å—Ç...")
                print(waitin)
                hours = waitin
                current_date_and_time = datetime.datetime.now()
                hours_added = datetime.timedelta(hours=int(hours))
                future_date_and_time = current_date_and_time + hours_added
                connect = psycopg2.connect(dbname='parsedaccounts', user='postgres',
                                           password=password, host='localhost')
                cur = connect.cursor()
                cur.execute(f"INSERT INTO channel_entity(channel, join_time, leave_time, bot_id) "
                            f"VALUES ('{entity}', '{current_date_and_time}', '{future_date_and_time}', {x})")
                connect.commit()
                connect.close()
                time.sleep(3)




        time.sleep(30)
        print("–ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞")
        connect = psycopg2.connect(dbname='parsedaccounts', user='postgres',
                                   password=password, host='localhost')
        cur = connect.cursor()
        cur.execute(f"SELECT id,channel, leave_time FROM channel_entity WHERE bot_id = {x}")
        all_channels = cur.fetchall()
        for channel in all_channels:
            if channel[2] < datetime.datetime.now():
                print(f"–£–¥–∞–ª—è–µ–º –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Ç.–∫. –≤—Ä–µ–º—è —É–∂–µ –ø—Ä–æ–π–¥–µ–Ω–æ"
                      f" {channel[0]}/{channel[1]}/{channel[2]}  < {datetime.datetime.now()}")
                try:
                    await asyncio.sleep(random.uniform(5, 10))
                    await client(LeaveChannelRequest(channel[1]))
                    await asyncio.sleep(random.uniform(0.1, 0.5))
                except errors.FloodWaitError as e:
                    print(f'–ù–∞—Å –æ–ø—Ä–∞–∫–∏–Ω—É–ª–∏ –µ–±–∞–ª–æ–º –≤ –≥—Ä—è–∑—å —Å–∏–¥–∏–º {e.seconds} —Å–µ–∫—É–Ω–¥')
                    time.sleep(e.seconds)

                finally:
                    cur.execute(f"DELETE FROM channel_entity WHERE id = {channel[0]}")
                    connect.commit()
                    break


        else:
            print(f"–ù–µ—Ç {channel[0]}/ {channel[1]} /{channel[2]}  > {datetime.datetime.now()}")


        connect.close()
        count += 1
        print("–í—ã–ø–æ–ª–Ω–µ–Ω–æ...")







def wrap(i):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    asyncio.run(workThread(i))
    loop.close()






if __name__ == '__main__':
    connect = psycopg2.connect(dbname='parsedaccounts', user='postgres',
                               password=password, host='localhost')
    cur1 = connect.cursor()
    cur1.execute("SELECT ID FROM RegistredBots")

    nums = cur1.fetchall()
    for num in nums:
        wrap(num[0])





#TODO –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥.
#TODO –ü–µ—Ä–µ–ø–∏—Å–∞—Ç—å –≤—ã–≤–æ–¥ –≤ –ø–æ—Ç–æ–∫–∏. –ü–µ—Ä–µ–ø–∏—Å–∞—Ç—å —Å—Ç—Ä–æ–∫—É –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è –ø–æ—Ç–æ–∫–æ–≤ SELECT Count(ID) FROM RegistredBots –Ω–∞ SELECT ID FROM RegistredBots –¥–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É
#TODO C–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ –æ–ø—Ä–∞–∫–∏–¥—ã–≤–∞—é—Ç –µ–±–∞–ª–æ–º –≤ –≥—Ä—è–∑—å. –õ—É—á—à–µ –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å, –¥–∞–±—ã –≤—ã–∑—ã–≤–∞—Ç—å –º–µ–Ω—å—à–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω—É –∏ —É —Ç–µ–ª–µ–≥–∏ –≤–æ–ø—Ä–æ—Å–æ–≤.